<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SODA Royale</title>
  <style>
    html, body { margin:0; padding:0; background:#05070b; color:#cfe7ff; font:14px/1.45 system-ui, Segoe UI, Roboto, Arial; touch-action:none; }
    #ui { position:fixed; inset:0 0 auto 0; padding:8px 10px; display:flex; gap:12px; align-items:center;
          background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,0)); user-select:none; z-index:10 }
    #hud { display:flex; gap:14px; align-items:center; flex-wrap:wrap }
    .chip { padding:4px 8px; border-radius:8px; background:#0e1622; border:1px solid #1b2940; }
    .btn { padding:4px 8px; border-radius:6px; background:#112033; border:1px solid #1c3355; color:#cfe7ff; cursor:pointer; }
    .btn[disabled] { opacity:.4; cursor:not-allowed; }
    #log { position:fixed; right:8px; top:40px; width:320px; max-height:44vh; overflow:auto; font-size:12px; opacity:.85; z-index:9 }
    #log div { margin:0 0 6px; padding:6px 8px; background:#0b1220; border:1px solid #14233d; border-radius:8px; }
    canvas { display:block; width:100vw; height:100vh; }

    #banner { position:fixed; inset:auto 0 40% 0; text-align:center; font-size:28px; font-weight:700; letter-spacing:1px; text-shadow:0 2px 10px #000; z-index:8 }

    /* Main menu */
    #menu {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(1200px 800px at 50% 30%, rgba(20,40,80,.35), rgba(0,0,0,.85));
      z-index:100; pointer-events:auto;
    }
    #menu .panel{
      width:min(720px,92vw); padding:22px; border-radius:16px; background:#0b1320ee; border:1px solid #1a2b4a;
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    #menu h1{ margin:0 0 12px; font-size:28px; letter-spacing:.5px }
    #menu h2{ margin:16px 0 8px; font-size:16px; opacity:.85 }
    #menu .row{ display:flex; gap:12px; flex-wrap:wrap }
    #menu .grow{ flex:1 }
    #menu .start{ font-size:16px; padding:10px 14px; border-radius:10px; background:#18406d; border:1px solid #295a91; cursor:pointer }
    #menu .start:hover{ background:#1b4e87 }
    #menu kbd{ background:#0f1b2d; border:1px solid #1c2f4f; padding:2px 6px; border-radius:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px }

    /* Mobile controls */
    .mobileOnly{ position:fixed; z-index:50; display:none; }
    .touch-btn{ touch-action:none; -webkit-user-select:none; user-select:none; background:#112033d0; border:1px solid #1c3355; color:#cfe7ff; border-radius:12px; padding:10px 14px; font-weight:700; }
    .joystick{ width:120px; height:120px; border-radius:60px; background:#0e1622a0; border:1px solid #1b2940; touch-action:none; }
    .stick{ position:absolute; width:56px; height:56px; border-radius:28px; background:#1a2a42; border:1px solid #274168; transform:translate(-50%,-50%); left:50%; top:50%; pointer-events:none; }
    @media (pointer:coarse){ .mobileOnly{ display:block; } }
    .hideDuringMenu{ pointer-events:none; opacity:0; }
  </style>
</head>
<body>
  <!-- MAIN MENU -->
  <div id="menu">
    <div class="panel">
      <h1>SODA Royale</h1>
      <div class="row">
        <button id="startBtn" class="start">Start Match</button>
        <div class="grow"></div>
      </div>
      <h2>Controls</h2>
      <div class="row">
        <div class="grow">
          <div><strong>PC</strong></div>
          <div>Move: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or <kbd>←↑→↓</kbd></div>
          <div>Aim: Mouse</div>
          <div>Shoot: <kbd>LMB</kbd> (hold for auto)</div>
          <div>Jetpack: <kbd>RMB</kbd> (hold)</div>
        </div>
        <div class="grow">
          <div><strong>Mobile</strong></div>
          <div>Left joystick: Move</div>
          <div>Right joystick: Look (no auto-shoot)</div>
          <div><span class="touch-btn" style="padding:2px 8px">SHOOT</span> to fire (hold)</div>
          <div><span class="touch-btn" style="padding:2px 8px">JET</span> to thrust (hold)</div>
        </div>
      </div>
    </div>
  </div>

  <div id="ui">
    <div id="hud">
      <span class="chip" id="hp">HP: 100</span>
      <span class="chip" id="suit">Suit: 100</span>
      <span class="chip" id="gun">Gun: -</span>
      <span class="chip" id="ammo">Ammo: 0</span>
      <span class="chip" id="cons">NanoInject×0 | Wrench×0 | Gravite×0</span>
      <span class="chip" id="zone">Zone: stable</span>
      <span class="chip" id="alive">Alive: -</span>
      <span class="chip" id="time">Time: 0:00</span>
    </div>
    <div style="flex:1"></div>
    <button class="btn" id="useNano">Use Nano</button>
    <button class="btn" id="useWrench">Use Wrench</button>
    <button class="btn" id="useGravite">Use Gravite</button>
  </div>

  <div id="log"></div>
  <div id="banner"></div>
  <canvas id="c"></canvas>

  <!-- MOBILE CONTROLS -->
  <div id="joyMove" class="mobileOnly joystick" style="left:18px; bottom:18px;">
    <div class="stick"></div>
  </div>
  <div id="joyLook" class="mobileOnly joystick" style="right:18px; bottom:18px;">
    <div class="stick"></div>
  </div>
  <button id="btnShoot" class="mobileOnly touch-btn" style="right:20px; bottom:160px;">SHOOT</button>
  <button id="btnJet"   class="mobileOnly touch-btn" style="right:120px; bottom:160px;">JET</button>

<script>
(() => {
  // ==============================
  // Utils
  // ==============================
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp01 = v => Math.max(0, Math.min(1, v));

  function chooseWeighted(entries){
    const total = entries.reduce((s,e)=>s+e.w,0);
    let r = Math.random()*total;
    for (const e of entries){ if ((r -= e.w) <= 0) return e.value; }
    return entries.at(-1).value;
  }

  function segmentHitsCircle(ax,ay,bx,by,cx,cy,r){
    const ABx = bx-ax, ABy = by-ay;
    const ACx = cx-ax, ACy = cy-ay;
    const ab2 = ABx*ABx + ABy*ABy || 1;
    let t = (ACx*ABx + ACy*ABy) / ab2;
    t = clamp01(t);
    const px = ax + ABx*t, py = ay + ABy*t;
    const dx = px - cx, dy = py - cy;
    return (dx*dx + dy*dy) <= r*r;
  }

  function hasLineOfSight(ax,ay,bx,by){
    for (const p of state.planets){
      if (segmentHitsCircle(ax,ay,bx,by,p.x,p.y,p.r)) return false;
    }
    return true;
  }

  // ==============================
  // Canvas / View
  // ==============================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const view = { w:0, h:0, dpr:1 };
  function resize(){
    view.dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    view.w = Math.floor(innerWidth);
    view.h = Math.floor(innerHeight);
    canvas.width  = Math.floor(view.w * view.dpr);
    canvas.height = Math.floor(view.h * view.dpr);
    ctx.setTransform(view.dpr, 0, 0, view.dpr, 0, 0); // draw in CSS px
  }
  addEventListener('resize', resize); resize();

  // ==============================
  // UI Log
  // ==============================
  const logEl = document.getElementById('log');
  function log(t){
    const d = document.createElement('div');
    d.textContent = t;
    logEl.prepend(d);
    while (logEl.children.length > 14) logEl.lastChild.remove();
  }

  // ==============================
  // Game State
  // ==============================
  const state = {
    time: 0,
    over: false,
    win: false,
    started: false,
    player: null,
    ai: [],
    bullets: [],
    explosions: [],
    loot: [],
    planets: [],
    inputs: { mx:0, my:0, lmb:false, rmb:false, keys:{}, move:{x:0,y:0}, shootHeld:false, jetHeld:false },
    zone: { x:0, y:0, r:3000, targetR:3000, phase:0, phaseTimer:18, shrinkTime:28, pauseTime:14, minR:28 },
    rules: {
      startBots: 50,
      lootSpawnEvery: 2.5,
      lastLootSpawn: 0,
      weaponGroundHardCap: 10,
      matchMinSeconds: 240,
      botSpeedScale: 0.72,
      aiMaxSpeed: 220,
      aiAccel: { zonePush: 32, chase: 24, ammoHunt: 40, wander: 18 },
      spawnInnerFrac: 0.62,
      spawnSafeMargin: 80,
      minBotSpacingFrac: 0.14
    }
  };

  // === MOBILE FIX: input mode + mouse activity tracker
  let inputMode = { touchSeen: false, mouseActiveTimer: 0 };
  function tickMouseTimer(dt){
    if (inputMode.mouseActiveTimer > 0) inputMode.mouseActiveTimer = Math.max(0, inputMode.mouseActiveTimer - dt);
  }

  // ==============================
  // Data
  // ==============================
  const Guns = {
    pistol: {name:'Small Blaster', tier:'common',   damage:10, bulletSpeed:520, spread:0.04, fireRate:4.0,  maxAmmo:60},
    smg:    {name:'Tactical Blaster', tier:'uncommon', damage:8, bulletSpeed:600, spread:0.08, fireRate:10.0, maxAmmo:160},
    rifle:  {name:'Rifle Blaster', tier:'uncommon', damage:14, bulletSpeed:700, spread:0.02, fireRate:6.0,  maxAmmo:120},
    gl:     {name:'Grenade Launcher', tier:'rare',   damage:28, bulletSpeed:360, spread:0.00, fireRate:1.0,  maxAmmo:12, splash:64}
  };
  const GunOrder = ['pistol','smg','rifle','gl'];

  const LootViz = {
    ammo:   { color:'#53e571', draw:(x,y)=>{ box(x,y); glyph(x,y,'A'); } },
    nano:   { color:'#55b6ff', draw:(x,y)=>{ circle(x,y); glyph(x,y,'+'); } },
    wrench: { color:'#ffd257', draw:(x,y)=>{ hex(x,y); glyph(x,y,'W'); } },
    gravite:{ color:'#c069ff', draw:(x,y)=>{ tri(x,y); glyph(x,y,'G'); } },
    gun:    { color:'#a6c8ff', draw:(x,y,kind)=>{ star(x,y); glyph(x,y, Guns[kind.gun].name.split(' ')[0][0]); } }
  };

  const WeightedLoot = [
    {w: 40, value: {type:'ammo', amount:30}},
    {w: 25, value: {type:'nano', amount:1}},
    {w: 25, value: {type:'wrench', amount:1}},
    {w: 16, value: {type:'gravite', amount:1}},
    {w:  6, value: {type:'gun', gun:'pistol'}},
    {w:  4, value: {type:'gun', gun:'smg'}},
    {w:  4, value: {type:'gun', gun:'rifle'}},
    {w:  2, value: {type:'gun', gun:'gl'}},
  ];

  // ==============================
  // Entities
  // ==============================
  function makePlayer(x,y,isAI=false){
    return {
      x, y, vx:0, vy:0, r:10,
      hp:100, suit:100, maxHp:100, maxSuit:100,
      gunKey:'pistol', ammo:30,
      inv:{nano:0,wrench:0,gravite:0},
      isAI,
      ai:{fireCd:0, thinkCd:0, tgt:null, hideTimer:0, wanderA:Math.random()*TAU},
      jet:{fuel:1, cd:0, active:false},
      onPlanet:false, angle:0
    };
  }

  function spawnAI(n){
    const inner = state.zone.r * state.rules.spawnInnerFrac;
    const outer = state.zone.r - state.rules.spawnSafeMargin;
    const minD  = state.zone.r * state.rules.minBotSpacingFrac;
    const farFromPlayer = minD * 1.6;

    const placed = [];
    let attempts = 0, maxAttempts = 8000;

    while (placed.length < n && attempts++ < maxAttempts){
      const a = Math.random() * TAU;
      const d = rand(inner, outer);
      const x = Math.cos(a) * d, y = Math.sin(a) * d;
      if (Math.hypot(x - state.player.x, y - state.player.y) < farFromPlayer) continue;
      let ok = true;
      for (const p of placed){
        if (Math.hypot(x - p.x, y - p.y) < minD){ ok = false; break; }
      }
      if (!ok) continue;
      const bot = makePlayer(x, y, true);
      bot.gunKey = GunOrder[Math.floor(rand(0, GunOrder.length))];
      bot.ammo   = Math.floor(Guns[bot.gunKey].maxAmmo * 0.28);
      placed.push({x,y});
      state.ai.push(bot);
    }
    while (state.ai.length < n){
      const a = Math.random() * TAU;
      const d = rand(inner, outer);
      const x = Math.cos(a) * d, y = Math.sin(a) * d;
      const bot = makePlayer(x, y, true);
      bot.gunKey = GunOrder[Math.floor(rand(0, GunOrder.length))];
      bot.ammo   = Math.floor(Guns[bot.gunKey].maxAmmo * 0.25);
      state.ai.push(bot);
    }
  }

  function genPlanets(){
    const count = 7;
    for(let i=0;i<count;i++){
      const a = Math.random()*TAU;
      const d = rand(160, 1000);
      const x = Math.cos(a)*d, y = Math.sin(a)*d;
      state.planets.push({
        x,y, r: rand(32,92),
        color: `hsl(${Math.floor(rand(180,320))} 45% 45%)`
      });
    }
  }

  // ==============================
  // Loot
  // ==============================
  function spawnLootBurst(n){ for(let i=0;i<n;i++) spawnLoot(); }
  function spawnLoot(){
    const weaponOnGround = state.loot.filter(l=>l.kind.type==='gun').length;
    let entry = chooseWeighted(WeightedLoot);
    if (entry.type === 'gun' && weaponOnGround >= state.rules.weaponGroundHardCap){
      entry = chooseWeighted(WeightedLoot.filter(e=>e.value.type!=='gun'));
    }
    const a = Math.random()*TAU;
    const d = rand(120, state.zone.r*0.9);
    const x = Math.cos(a)*d, y = Math.sin(a)*d;
    state.loot.push({ x,y, r:9, kind:entry, ttl: 180 });
  }

  // ==============================
  // Input
  // ==============================
  const keys = state.inputs.keys;
  addEventListener('keydown', e=>{ if (!state.started && e.code==='Enter') startMatch(); keys[e.code]=true; });
  addEventListener('keyup',   e=>{ keys[e.code]=false; });
  addEventListener('blur', ()=>{ state.inputs.lmb=false; state.inputs.rmb=false; });

  addEventListener('contextmenu', e=>e.preventDefault());

  // Mouse aiming relative to canvas center
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    state.inputs.mx = e.clientX - rect.left - rect.width/2;
    state.inputs.my = e.clientY - rect.top  - rect.height/2;
    inputMode.mouseActiveTimer = 1.0;
  });

  canvas.addEventListener('mousedown', e=>{
    state.inputs.lmb = (e.button===0);
    state.inputs.rmb = (e.button===2);
    inputMode.mouseActiveTimer = 1.0; // keep PC click responsive even after idle
  });
  canvas.addEventListener('mouseup', e=>{
    if (e.button===0) state.inputs.lmb = false;
    if (e.button===2) state.inputs.rmb = false;
  });

  addEventListener('pointerdown', e=>{
    if (e.pointerType && e.pointerType !== 'mouse') inputMode.touchSeen = true;
  }, {passive:true});

  // ==============================
  // Combat
  // ==============================
  function tryShoot(p, dt, aiShot=false){
    const gun = Guns[p.gunKey];
    if (!gun) return;
    p.ai.fireCd = Math.max(0, p.ai.fireCd - dt);

    if (p.isAI) {
      if (p.ai.fireCd>0 || !p.ai.tgt || p.ammo<=0) return;
    } else {
      // on touch, only SHOOT button can fire; on PC, mouse must be recently active
      const mouseActive = inputMode.mouseActiveTimer > 0;
      const wantsToShoot = (mouseActive ? state.inputs.lmb : false) || state.inputs.shootHeld;
      if (!wantsToShoot || p.ai.fireCd>0 || p.ammo<=0) return;
    }

    p.ai.fireCd = 1.0 / gun.fireRate;

    // === FACING-FIRE CHANGE ===
    // Players: fire along current facing (p.angle). AI: still aim at target.
    let ang;
    if (p.isAI && p.ai.tgt){
      const base = Math.atan2(p.ai.tgt.y - p.y, p.ai.tgt.x - p.x);
      const extraAI = aiShot ? 0.06 : 0.0;
      ang = base + (gun.spread ? rand(-(gun.spread+extraAI), (gun.spread+extraAI)) : 0);
      p.angle = base; // AI turns to face target
    } else {
      ang = p.angle + (gun.spread ? rand(-gun.spread, gun.spread) : 0);
      // do NOT overwrite p.angle for player; keep their facing stable
    }

    const muzzle = p.r + 2;
    const b = {
      x: p.x + Math.cos(ang)*muzzle,
      y: p.y + Math.sin(ang)*muzzle,
      vx: Math.cos(ang) * gun.bulletSpeed,
      vy: Math.sin(ang) * gun.bulletSpeed,
      from:p, ttl: 2.5, r: gun.splash?6:3, gl: !!gun.splash, damage: gun.damage
    };
    state.bullets.push(b);
    p.ammo--;
  }

  function damageEntity(tgt, amount){
    if (tgt.suit>0){
      const sDmg = Math.min(tgt.suit, amount);
      tgt.suit -= sDmg; amount -= sDmg;
    }
    if (amount>0) tgt.hp = Math.max(0, tgt.hp - amount);
  }

  function explode(x,y,r){ state.explosions.push({x,y,r,ttl:0.25}); }

  // ==============================
  // AI
  // ==============================
  function aiThink(bot, dt){
    bot.ai.thinkCd = Math.max(0, bot.ai.thinkCd - dt);
    if (bot.ai.thinkCd>0) return;
    bot.ai.thinkCd = rand(0.24, 0.38);
    const candidates = [state.player, ...state.ai.filter(a=>a!==bot)];
    let best=null, bestD=1e9;
    for (const c of candidates){
      if (c.hp<=0) continue;
      const d = Math.hypot(c.x-bot.x, c.y-bot.y);
      if (d < bestD){ best = c; bestD = d; }
    }
    bot.ai.tgt = best;
    if (best) bot.angle = Math.atan2(best.y-bot.y, best.x-bot.x);
  }

  function aiUpdate(bot, dt){
    aiThink(bot, dt);
    const scale = state.rules.botSpeedScale;
    const A = state.rules.aiAccel;
    if ((bot.hp < 50 || bot.suit < 30) && bot.ai.hideTimer <= 0) bot.ai.hideTimer = rand(1.2,2.2);
    if (bot.ai.hideTimer > 0){
      bot.ai.hideTimer -= dt;
      const tang = Math.atan2(bot.y-state.zone.y, bot.x-state.zone.x) + Math.PI/2;
      bot.vx += Math.cos(tang)*A.wander*scale*dt;
      bot.vy += Math.sin(tang)*A.wander*scale*dt;
    }
    if (bot.ammo <= 0){
      let nearest=null, nd=1e9;
      for (const l of state.loot){
        if (l.kind.type==='ammo' || l.kind.type==='gun'){
          const d=Math.hypot(l.x-bot.x, l.y-bot.y);
          if (d<nd){ nd=d; nearest=l; }
        }
      }
      if (nearest){
        const a=Math.atan2(nearest.y-bot.y, nearest.x-bot.x);
        bot.vx += Math.cos(a)*A.ammoHunt*scale*dt;
        bot.vy += Math.sin(a)*A.ammoHunt*scale*dt;
        return;
      } else {
        bot.ai.wanderA += rand(-0.3,0.3)*dt;
        bot.vx += Math.cos(bot.ai.wanderA)*A.wander*scale*dt;
        bot.vy += Math.sin(bot.ai.wanderA)*A.wander*scale*dt;
        return;
      }
    }
    if (bot.ai.tgt){
      const zdx = bot.x - state.zone.x, zdy = bot.y - state.zone.y;
      const zr = Math.hypot(zdx,zdy);
      if (zr > state.zone.r*0.95){
        const a = Math.atan2(state.zone.y-bot.y, state.zone.x-bot.x);
        bot.vx += Math.cos(a)*A.zonePush*scale*dt;
        bot.vy += Math.sin(a)*A.zonePush*scale*dt;
      } else {
        const a = Math.atan2(bot.ai.tgt.y-bot.y, bot.ai.tgt.x-bot.x);
        bot.vx += Math.cos(a)*A.chase*scale*dt;
        bot.vy += Math.sin(a)*A.chase*scale*dt;
      }
      const d = Math.hypot(bot.ai.tgt.x-bot.x, bot.ai.tgt.y-bot.y);
      const engageRange = 460;
      const hardMaxRange = 680;
      const inRange = d < engageRange || (d < hardMaxRange && Math.random() < 0.15);
      bot.ai.fireCd = Math.max(0, bot.ai.fireCd - dt);
      if (bot.ai.fireCd === 0 && Math.random() < 0.20){
        bot.ai.fireCd = rand(0.12, 0.28);
      }
      if (inRange && bot.ammo > 0 && hasLineOfSight(bot.x, bot.y, bot.ai.tgt.x, bot.ai.tgt.y)){
        tryShoot(bot, dt, /*aiShot=*/true);
      }
    }
  }

  // ==============================
  // Planets / Ground contact
  // ==============================
  function planetAt(x,y){
    for (const p of state.planets){
      if (Math.hypot(x-p.x, y-p.y) <= p.r + 12) return p;
    }
    return null;
  }

  // ==============================
  // Zone
  // ==============================
  function updateZone(dt){
    const z = state.zone;
    z.phaseTimer -= dt;
    if (z.phaseTimer <= 0){
      if (z.targetR <= z.minR){
        z.targetR = z.minR;
        z.r = lerp(z.r, z.targetR, 1 - Math.pow(0.001, dt));
        return;
      }
      if (z.phase === 0){ // start shrinking
        z.phase = 1; z.phaseTimer = z.shrinkTime;
        z.targetR = Math.max(z.minR, z.r * 0.68);
      } else { // pause
        z.phase = 0; z.phaseTimer = z.pauseTime;
      }
    }
    if (z.phase === 1){
      const t = clamp(1 - (z.phaseTimer / z.shrinkTime), 0, 1);
      z.r = lerp(z.r, z.targetR, t*dt*1.4);
    }
  }

  // ==============================
  // Camera
  // ==============================
  const cam = { x:0, y:0 };
  function updateCamera(dt){
    cam.x = lerp(cam.x, state.player.x, 0.18);
    cam.y = lerp(cam.y, state.player.y, 0.18);
  }

  // ==============================
  // Init
  // ==============================
  state.player = makePlayer(0,0,false);
  genPlanets();
  spawnAI(state.rules.startBots);
  spawnLootBurst(28);

  // ==============================
  // Loop
  // ==============================
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now; if (state.started) state.time += dt;
    tickMouseTimer(dt);
    step(dt); draw(dt);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ==============================
  // Step
  // ==============================
  function step(dt){
    if (!state.started){
      updateCamera(dt);
      return;
    }
    if (state.over) return;

    updateZone(dt);
    if (state.time - state.rules.lastLootSpawn > state.rules.lootSpawnEvery){
      state.rules.lastLootSpawn = state.time;
      spawnLoot();
    }

    // Movement input (PC keys + left joystick)
    const mv = state.inputs.move;
    const keyX = (keys.KeyD||keys.ArrowRight?1:0) - (keys.KeyA||keys.ArrowLeft?1:0);
    const keyY = (keys.KeyS||keys.ArrowDown?1:0) - (keys.KeyW||keys.ArrowUp?1:0);
    const inX = mv.x || keyX, inY = mv.y || keyY;
    if (inX || inY){
      const len = Math.hypot(inX,inY) || 1;
      const spd = 40;
      state.player.vx += (inX/len)*spd*dt;
      state.player.vy += (inY/len)*spd*dt;
    }

    // Aim source priority
    const mouseActive = inputMode.mouseActiveTimer > 0;
    if (joyLook.active){
      // angle already set in joystick handler
    } else if (mouseActive){
      state.player.angle = Math.atan2(state.inputs.my + cam.y - state.player.y,
                                      state.inputs.mx + cam.x - state.player.x);
    }

    // Planet contact
    const touchingPlanet = planetAt(state.player.x, state.player.y);
    state.player.onPlanet = !!touchingPlanet;

    // Jetpack (with pop off planet for clean lift)
    const jet = state.player.jet;
    jet.cd = Math.max(0, jet.cd - dt);
    const jetHeld = state.inputs.rmb || state.inputs.jetHeld;
    if (jetHeld && jet.fuel > 0){
      if (state.player.onPlanet && jet.cd <= 0){
        const nx = (state.player.x - touchingPlanet.x);
        const ny = (state.player.y - touchingPlanet.y);
        const nlen = Math.hypot(nx, ny) || 1;
        const pop = 28;
        state.player.vx += (nx/nlen) * pop;
        state.player.vy += (ny/nlen) * pop;
        jet.cd = 0.18;
      }
      jet.active = true;
      const thrust = 160;
      state.player.vx += Math.cos(state.player.angle)*thrust*dt;
      state.player.vy += Math.sin(state.player.angle)*thrust*dt;
      jet.fuel = Math.max(0, jet.fuel - dt*0.45);
    } else {
      jet.active = false;
      if (!jetHeld) jet.fuel = clamp(jet.fuel + dt*0.18, 0, 1 + (state.player.inv.gravite>0?0.5:0));
    }

    // Shooting
    tryShoot(state.player, dt);

    // AI
    for (const bot of state.ai){ if (bot.hp>0) aiUpdate(bot, dt); }

    // Integrate + zone damage
    const allUnits = [state.player, ...state.ai];
    for (const u of allUnits){
      u.vx *= (1-0.08);
      u.vy *= (1-0.08);
      const spd = Math.hypot(u.vx,u.vy);
      const maxSpd = u.isAI ? state.rules.aiMaxSpeed : 260;
      if (spd>maxSpd){ u.vx *= maxSpd/spd; u.vy *= maxSpd/spd; }
      u.x += u.vx*dt*60;
      u.y += u.vy*dt*60;
      const dz = Math.hypot(u.x-state.zone.x, u.y-state.zone.y) - state.zone.r;
      if (dz>0) damageEntity(u, dz*dt*2);
    }

    // Pickups
    function pickup(p){
      for (let i=state.loot.length-1;i>=0;i--){
        const L = state.loot[i];
        L.ttl -= dt; if (L.ttl<=0){ state.loot.splice(i,1); continue; }
        if (Math.hypot(p.x-L.x, p.y-L.y) < 18){
          const k = L.kind;
          if (k.type==='ammo'){
            const g = Guns[p.gunKey];
            const add = k.amount;
            p.ammo = Math.min(g.maxAmmo, p.ammo + add);
            if (!p.isAI) log(`Picked Ammo +${add}`);
          } else if (k.type==='gun'){
            p.gunKey = k.gun;
            const g = Guns[k.gun];
            const add = Math.floor(g.maxAmmo/3);
            p.ammo = Math.min(g.maxAmmo, p.ammo + add);
            if (!p.isAI) log(`Picked ${g.name}`);
          } else if (k.type==='nano'){
            p.inv.nano++; if (!p.isAI) log('Picked NanoInject');
          } else if (k.type==='wrench'){
            p.inv.wrench++; if (!p.isAI) log('Picked Wrench');
          } else if (k.type==='gravite'){
            p.inv.gravite++; if (!p.isAI) log('Picked Gravite');
          }
          state.loot.splice(i,1);
        }
      }
    }
    pickup(state.player);
    for (const bot of state.ai) if (bot.hp>0) pickup(bot);

    // Bullets
    for (let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.ttl -= dt; if (b.ttl<=0){ state.bullets.splice(i,1); continue; }
      b.x += b.vx*dt; b.y += b.vy*dt;
      const targets = [state.player, ...state.ai];
      for (const t of targets){
        if (t===b.from || t.hp<=0) continue;
        if (Math.hypot(t.x-b.x, t.y-b.y) < (t.r + b.r)){
          if (b.gl){ explode(b.x,b.y, Guns.gl.splash); } else { damageEntity(t, b.damage); }
          state.bullets.splice(i,1); break;
        }
      }
    }

    // Explosions
    for (let i=state.explosions.length-1;i>=0;i--){
      const ex = state.explosions[i];
      ex.ttl -= dt; if (ex.ttl<=0){ state.explosions.splice(i,1); continue; }
      const targets = [state.player, ...state.ai];
      for (const t of targets){
        const d = Math.hypot(t.x-ex.x, t.y-ex.y);
        if (d < ex.r){
          const fall = 1 - (d/ex.r);
          damageEntity(t, Guns.gl.damage * (0.6 + 0.4*fall));
        }
      }
    }

    // Cleanup AIs
    for (let i=state.ai.length-1;i>=0;i--){ if (state.ai[i].hp<=0) state.ai.splice(i,1); }

    // Win/Lose
    if (state.player.hp<=0 && !state.over){ state.over=true; state.win=false; document.getElementById('banner').textContent='DEFEAT'; }
    if (state.ai.length===0 && state.player.hp>0 && !state.over){ state.over=true; state.win=true; document.getElementById('banner').textContent='VICTORY!'; }

    // Camera AFTER movement
    updateCamera(dt);

    // HUD
    const p = state.player, z = state.zone, g = Guns[p.gunKey];
    document.getElementById('hp').textContent   = `HP: ${Math.ceil(p.hp)}`;
    document.getElementById('suit').textContent = `Suit: ${Math.ceil(p.suit)}`;
    document.getElementById('gun').textContent  = `Gun: ${g.name}`;
    document.getElementById('ammo').textContent = `Ammo: ${p.ammo}/${g.maxAmmo}`;
    document.getElementById('cons').textContent = `NanoInject×${p.inv.nano} | Wrench×${p.inv.wrench} | Gravite×${p.inv.gravite}`;
    document.getElementById('zone').textContent = `Field: ${z.phase===0?`stable ${z.phaseTimer.toFixed(1)}s`:`shrinking ${z.phaseTimer.toFixed(1)}s`} r=${z.r.toFixed(0)}`;
    document.getElementById('alive').textContent= `Alive: ${1+state.ai.length}`;
    document.getElementById('time').textContent = `Time: ${fmtTime(state.time)}`;

    // Buttons enablement
    useNano.disabled    = !(p.inv.nano   > 0 && p.hp   < p.maxHp);
    useWrench.disabled  = !(p.inv.wrench > 0 && p.suit < p.maxSuit);
    useGravite.disabled = !(p.inv.gravite> 0);
  }

  // ==============================
  // Draw
  // ==============================
  function draw(dt){
    ctx.clearRect(0,0,view.w,view.h);
    ctx.save();
    ctx.translate(view.w/2 - cam.x, view.h/2 - cam.y);

    // Zone ring
    ctx.beginPath(); ctx.strokeStyle='#2a5cff'; ctx.lineWidth=2; ctx.globalAlpha=0.6;
    ctx.arc(state.zone.x, state.zone.y, state.zone.r, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;

    // Planets
    for (const p of state.planets){
      ctx.beginPath(); ctx.fillStyle=p.color; ctx.globalAlpha=0.9;
      ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    }

    // Loot
    for (const L of state.loot){
      const kind = L.kind;
      ctx.save();
      ctx.globalAlpha = clamp(L.ttl, 0.3, 1);
      ctx.fillStyle = LootViz[kind.type].color;
      LootViz[kind.type].draw(L.x, L.y, kind);
      ctx.restore();
    }

    // Bullets
    ctx.fillStyle = '#cfe7ff';
    for (const b of state.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fill(); }

    // Explosions
    for (const ex of state.explosions){
      const k = clamp(ex.ttl/0.25,0,1);
      const rr = Math.max(0, ex.r * k);
      ctx.beginPath(); ctx.strokeStyle='#ff9a55'; ctx.lineWidth=2; ctx.globalAlpha=0.6*k;
      ctx.arc(ex.x, ex.y, rr, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;
    }

    // Units
    function drawUnit(u, col){
      ctx.save(); ctx.translate(u.x, u.y); ctx.rotate(u.angle);
      ctx.fillStyle=col; ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-10,7); ctx.lineTo(-10,-7); ctx.closePath(); ctx.fill();
      ctx.restore();
      // bars
      ctx.fillStyle='#1c2e4a'; ctx.fillRect(u.x-10, u.y-18, 20, 3);
      ctx.fillStyle='#4eb1ff'; ctx.fillRect(u.x-10, u.y-18, 20*(u.suit/u.maxSuit), 3);
      ctx.fillStyle='#1c2e4a'; ctx.fillRect(u.x-10, u.y-14, 20, 3);
      ctx.fillStyle='#7cff91'; ctx.fillRect(u.x-10, u.y-14, 20*(u.hp/u.maxHp), 3);
    }
    drawUnit(state.player, '#8fd5ff');
    for (const bot of state.ai){ drawUnit(bot, '#ff8f8f'); }

    ctx.restore();
  }

  // ==============================
  // Glyph helpers
  // ==============================
  function box(x,y){ ctx.fillRect(x-8,y-8,16,16); }
  function circle(x,y){ ctx.beginPath(); ctx.arc(x,y,9,0,TAU); ctx.fill(); }
  function tri(x,y){ ctx.beginPath(); ctx.moveTo(x,y-10); ctx.lineTo(x+9,y+7); ctx.lineTo(x-9,y+7); ctx.closePath(); ctx.fill(); }
  function hex(x,y){ ctx.beginPath(); for (let i=0;i<6;i++){ const a=i*TAU/6; const px=x+Math.cos(a)*10, py=y+Math.sin(a)*10; i?ctx.lineTo(px,py):ctx.moveTo(px,py); } ctx.closePath(); ctx.fill(); }
  function star(x,y){
    ctx.beginPath();
    for (let i=0;i<10;i++){
      const r=(i%2?5:10);
      const a=i*TAU/10;
      const px=x+Math.cos(a)*r, py=y+Math.sin(a)*r;
      i ? ctx.lineTo(px,py) : ctx.moveTo(px,py); // <-- fixed moveTo
    }
    ctx.closePath(); ctx.fill();
  }
  function glyph(x,y,t){ ctx.fillStyle='#07111f'; ctx.font='10px system-ui,Segoe UI,Roboto,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(t,x,y); }

  // ==============================
  // Consumables
  // ==============================
  const useNano    = document.getElementById('useNano');
  const useWrench  = document.getElementById('useWrench');
  const useGravite = document.getElementById('useGravite');

  useNano.addEventListener('click', ()=>{ const p = state.player; if (p.inv.nano<=0 || p.hp>=p.maxHp) return;
    p.inv.nano--; p.hp = Math.min(p.maxHp, p.hp+40); log('Used NanoInject'); });
  useWrench.addEventListener('click', ()=>{ const p = state.player; if (p.inv.wrench<=0 || p.suit>=p.maxSuit) return;
    p.inv.wrench--; p.suit = Math.min(p.maxSuit, p.suit+40); log('Used Wrench'); });
  useGravite.addEventListener('click', ()=>{ const p = state.player; if (p.inv.gravite<=0) return;
    p.inv.gravite--; p.jet.cd = 0; p.jet.fuel = Math.min(1.5, p.jet.fuel + 0.5); log('Used Gravite (jet boost)'); });

  // ==============================
  // Helpers
  // ==============================
  function fmtTime(t){ const s=Math.floor(t%60), m=Math.floor(t/60); return `${m}:${s.toString().padStart(2,'0')}`; }

  // ==============================
  // Main menu
  // ==============================
  const menu = document.getElementById('menu');
  const startBtn = document.getElementById('startBtn');
  const mobileElems = [document.getElementById('joyMove'), document.getElementById('joyLook'),
                       document.getElementById('btnShoot'), document.getElementById('btnJet')];

  function setMobileHidden(hide){
    for (const el of mobileElems){
      el.classList.toggle('hideDuringMenu', hide);
    }
  }
  setMobileHidden(true);

  function startMatch(){
    if (state.started) return;
    state.started = true;
    menu.style.display = 'none';
    setMobileHidden(false);
    log('Match started');
  }
  startBtn.addEventListener('click', startMatch);

  // ==============================
  // Mobile Buttons: SHOOT / JET (stable hold)
  // ==============================
  const btnShoot = document.getElementById('btnShoot');
  const btnJet   = document.getElementById('btnJet');

  ['pointerdown','pointerup','pointercancel','lostpointercapture'].forEach(ev => {
    btnShoot.addEventListener(ev, e => {
      e.preventDefault();
      if (ev === 'pointerdown') {
        btnShoot.setPointerCapture(e.pointerId);
        state.inputs.shootHeld = true;
      } else {
        state.inputs.shootHeld = false;
      }
    }, { passive:false });
  });

  ['pointerdown','pointerup','pointercancel','lostpointercapture'].forEach(ev => {
    btnJet.addEventListener(ev, e => {
      e.preventDefault();
      if (ev === 'pointerdown') {
        btnJet.setPointerCapture(e.pointerId);
        state.inputs.jetHeld = true;
      } else {
        state.inputs.jetHeld = false;
      }
    }, { passive:false });
  });

  // ==============================
  // Virtual Joysticks
  // ==============================
  function makeJoystick(root, onMove){
    const stick = root.querySelector('.stick');
    const center = { x: root.clientWidth/2, y: root.clientHeight/2 };
    let active = false, pid = null;

    function setStick(dx,dy){
      const radius = 48;
      const len = Math.hypot(dx,dy);
      const cl = len>radius ? radius/len : 1;
      const sx = center.x + dx*cl, sy = center.y + dy*cl;
      stick.style.left = sx + 'px'; stick.style.top = sy + 'px';
      const outX = (dx*cl)/radius, outY = (dy*cl)/radius;
      onMove(outX, outY, true);
    }
    function reset(){
      stick.style.left = center.x+'px'; stick.style.top = center.y+'px';
      onMove(0,0,false);
    }

    root.addEventListener('pointerdown', e=>{
      e.preventDefault();
      active = true; pid = e.pointerId; root.setPointerCapture(pid);
      const rect = root.getBoundingClientRect();
      setStick(e.clientX-rect.left-center.x, e.clientY-rect.top-center.y);
    }, {passive:false});
    root.addEventListener('pointermove', e=>{
      if (!active || e.pointerId!==pid) return;
      const rect = root.getBoundingClientRect();
      setStick(e.clientX-rect.left-center.x, e.clientY-rect.top-center.y);
    });
    function end(e){
      if (!active || (pid!==null && e.pointerId!==pid)) return;
      active=false; try{ root.releasePointerCapture(pid); }catch{}
      pid=null; reset();
    }
    root.addEventListener('pointerup', end);
    root.addEventListener('pointercancel', end);
    root.addEventListener('lostpointercapture', end);

    return { get active(){ return active; } };
  }

  const joyMoveEl = document.getElementById('joyMove');
  const joyLookEl = document.getElementById('joyLook');

  const joyMove = makeJoystick(joyMoveEl, (x,y,act)=>{
    state.inputs.move.x = x;
    state.inputs.move.y = y;
  });

  const joyLook = makeJoystick(joyLookEl, (x,y,act)=>{
    if (act && (x!==0 || y!==0)){
      const ang = Math.atan2(y, x);
      state.player.angle = ang;
    }
  });

  // ==============================
  // Sanity Checks
  // ==============================
  console.assert(Guns.pistol.fireRate !== Guns.smg.fireRate && Guns.smg.fireRate !== Guns.rifle.fireRate && Guns.gl.fireRate !== Guns.pistol.fireRate, 'distinct fire rates');
  (function(){
    const gunW = WeightedLoot.filter(e=>e.value.type==='gun').reduce((s,e)=>s+e.w,0);
    const otherW = WeightedLoot.filter(e=>e.value.type!=='gun').reduce((s,e)=>s+e.w,0);
    console.assert(otherW > gunW, 'non-weapon loot weighted more');
  })();
})();
</script>
</body>
</html>
